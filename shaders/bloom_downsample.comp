#version 460
#extension GL_ARB_separate_shader_objects : enable

#include "pl_shader_interop_renderer.h"

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform image2D target;
layout(set = 0, binding = 1) uniform texture2D source;
layout(set = 0, binding = 2)  uniform sampler tSamplerLinearClamp;

layout(set = 3, binding = 0) uniform PL_DYNAMIC_DATA
{
    plGpuDynBloomData tData;
} tDynamicData;

vec3 PowVec3(vec3 v, float p)
{
    return vec3(pow(v.x, p), pow(v.y, p), pow(v.z, p));
}

const float invGamma = 1.0 / 2.2;
vec3 ToSRGB(vec3 v) { return PowVec3(v, invGamma); }

float RGBToLuminance(vec3 col)
{
    return dot(col, vec3(0.2126f, 0.7152f, 0.0722f));
}

float KarisAverage(vec3 col)
{
    // Formula is 1 / (1 + luma)
    float luma = RGBToLuminance(ToSRGB(col)) * 0.25f;
    return 1.0f / (1.0f + luma);
}

void main()
{
    ivec2 iUV = ivec2(gl_GlobalInvocationID.xy);
    ivec2 targetResolution = imageSize(target);

    if(iUV.x >= targetResolution.x || iUV.y >= targetResolution.y)
        return;

    vec2 uv = (iUV + 0.5f) / vec2(targetResolution);

    ivec2 srcResolution = textureSize(sampler2D(source, tSamplerLinearClamp), 0);
    vec2 texelSize = 1.f / vec2(srcResolution);

    vec3 color = vec3(0);



    //sampling pattern from "Next Generation Post Processing in Call of Duty Advanced Warfare"
    //center 
    vec3 e = textureLod(sampler2D(source, tSamplerLinearClamp), uv,   0).rgb;

    //center pixel corners
    vec3 j = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(0.5, 0.5),   0).rgb;
    vec3 k = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(0.5, -0.5),  0).rgb;
    vec3 l = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(-0.5, 0.5),  0).rgb;
    vec3 m = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(-0.5, -0.5), 0).rgb;

    //left, rigth, up and down
    vec3 b = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2( 1.5, 0),  0).rgb;
    vec3 d = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(-1.5, 0),  0).rgb;
    vec3 f = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(0,  1.5),  0).rgb;
    vec3 h = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(0, -1.5),  0).rgb;

    //diagonal corners
    vec3 a = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2( 1.5,  1.5),  0).rgb;
    vec3 c = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2( 1.5, -1.5),  0).rgb;
    vec3 g = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(-1.5,  1.5),  0).rgb;
    vec3 i = textureLod(sampler2D(source, tSamplerLinearClamp), uv + texelSize * vec2(-1.5, -1.5),  0).rgb;

    // vec3 groups[5];
    // switch (tDynamicData.tData.iMipLevel)
    // {
    // case 0:
    //     // We are writing to mip 0, so we need to apply Karis average to each block
    //     // of 4 samples to prevent fireflies (very bright subpixels, leads to pulsating
    //     // artifacts).
    //     groups[0] = (a+b+d+e) * (0.125f/4.0f);
    //     groups[1] = (b+c+e+f) * (0.125f/4.0f);
    //     groups[2] = (d+e+g+h) * (0.125f/4.0f);
    //     groups[3] = (e+f+h+i) * (0.125f/4.0f);
    //     groups[4] = (j+k+l+m) * (0.5f/4.0f);
    //     groups[0] *= KarisAverage(groups[0]);
    //     groups[1] *= KarisAverage(groups[1]);
    //     groups[2] *= KarisAverage(groups[2]);
    //     groups[3] *= KarisAverage(groups[3]);
    //     groups[4] *= KarisAverage(groups[4]);
    //     color = groups[0]+groups[1]+groups[2]+groups[3]+groups[4];
    //     break;
    // default:
        color = e*0.125;
        color += (a+c+g+i)*0.03125;
        color += (b+d+f+h)*0.0625;
        color += (j+k+l+m)*0.125;
    //     break;
    // }

    color = clamp(color, 0.0, 100.0);
    imageStore(target, iUV, vec4(color, 0));
}