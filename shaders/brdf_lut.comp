#version 450
#extension GL_ARB_separate_shader_objects : enable

#include "math.glsl"
#include "brdf.glsl"
#include "sampling.inc"
#include "pl_shader_interop.h"
#include "pl_shader_interop_renderer.h"

layout(std140, set = 0, binding = 0) buffer _tBufferOut{ vec4 atPixelData[]; } tLUTOut;

//-----------------------------------------------------------------------------
// [SECTION] dynamic bind group
//-----------------------------------------------------------------------------

layout(set = 3, binding = 0) uniform PL_DYNAMIC_DATA
{
    plGpuDynFilterSpec tData;
} tDynamicData;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

void
main()
{
    const float fXCoord = gl_WorkGroupID.x * 16 + gl_LocalInvocationID.x;
    const float fYCoord = gl_WorkGroupID.y * 16 + gl_LocalInvocationID.y;

    const float fLutxinc = 1.0 / float(tDynamicData.tData.iResolution);
    const float fLutyinc = 1.0 / float(tDynamicData.tData.iResolution);
    vec2 tLutUV = vec2(max(fXCoord * fLutxinc, 0.1), max(fYCoord * fLutyinc, 0.0001));
    const int iCurrentLUTPixel = int(fXCoord + fYCoord * float(tDynamicData.tData.iResolution));

    float fNdotV = tLutUV.x;
    float fRoughness = tLutUV.y;

    // Compute LUT for GGX distribution.
    // See https://blog.selfshadow.com/publications/s2013-shading-course/karis/s2013_pbs_epic_notes_v2.pdf

    // Compute spherical view vector: (sin(phi), 0, cos(phi))
    const vec3 tV = vec3(sqrt(1.0 - fNdotV * fNdotV), 0.0, fNdotV);

    // The macro surface normal just points up.
    const vec3 tN = vec3(0.0, 0.0, 1.0);

    // To make the LUT independant from the material's F0, which is part of the Fresnel term
    // when substituted by Schlick's approximation, we factor it out of the integral,
    // yielding to the form: F0 * I1 + I2
    // I1 and I2 are slighlty different in the Fresnel term, but both only depend on
    // NoL and roughness, so they are both numerically integrated and written into two channels.
    float fA = 0.0;
    float fB = 0.0;
    float fC = 0.0;

    for(int i = 0; i < tDynamicData.tData.iSampleCount; ++i)
    {
        // generate a quasi monte carlo point in the unit square [0.1)^2
        vec2 tXi = pl_hammersley_2d(i, tDynamicData.tData.iSampleCount);
        vec3 tSampleDirection = pl_get_importance_sample_ggx(tXi, tN, fRoughness);
        vec3 tL = normalize(reflect(-tV, tSampleDirection));

        float fNdotL = pl_saturate(tL.z);
        float fNdotH = pl_saturate(tSampleDirection.z);
        float fVdotH = pl_saturate(dot(tV, tSampleDirection));
        if (fNdotL > 0.0)
        {

            // LUT for GGX distribution.

            // Taken from: https://bruop.github.io/ibl
            // Shadertoy: https://www.shadertoy.com/view/3lXXDB
            // Terms besides V are from the GGX PDF we're dividing by.
            float fVPdf = pl_masking_shadowing_ggx(fNdotL, fNdotV, fRoughness) * fVdotH * fNdotL / fNdotH;
            // fVPdf /= 4.0;
            float fFc = pow(1.0 - fVdotH, 5.0);
            fA += (1.0 - fFc) * fVPdf;
            fB += fFc * fVPdf;
            fC += 0.0;
        }
    }

    // The PDF is simply pdf(v, h) -> NDF * <nh>.
    // To parametrize the PDF over l, use the Jacobian transform, yielding to: pdf(v, l) -> NDF * <nh> / 4<vh>
    // Since the BRDF divide through the PDF to be normalized, the 4 can be pulled out of the integral.
    vec3 tColor =  vec3(4.0 * fA, 4.0 * fB, 4.0 * 2.0 * PL_PI * fC) / float(tDynamicData.tData.iSampleCount);

    tLUTOut.atPixelData[iCurrentLUTPixel] = vec4(tColor, 1.0);
}