#version 450
#extension GL_ARB_separate_shader_objects : enable

#include "math.glsl"
#include "sampling.inc"
#include "cube.inc"
#include "pl_shader_interop.h"
#include "pl_shader_interop_renderer.h"

layout(set = 0, binding = 0)  uniform sampler tDefaultSampler;
layout(set = 0, binding = 1) uniform textureCube uCubeMap;
layout(std140, set = 1, binding = 0) buffer _tBufferOut0{ vec4 atPixelData[]; } tFaceOut0;
layout(std140, set = 1, binding = 1) buffer _tBufferOut1{ vec4 atPixelData[]; } tFaceOut1;
layout(std140, set = 1, binding = 2) buffer _tBufferOut2{ vec4 atPixelData[]; } tFaceOut2;
layout(std140, set = 1, binding = 3) buffer _tBufferOut3{ vec4 atPixelData[]; } tFaceOut3;
layout(std140, set = 1, binding = 4) buffer _tBufferOut4{ vec4 atPixelData[]; } tFaceOut4;
layout(std140, set = 1, binding = 5) buffer _tBufferOut5{ vec4 atPixelData[]; } tFaceOut5;

//-----------------------------------------------------------------------------
// [SECTION] dynamic bind group
//-----------------------------------------------------------------------------

layout(set = 3, binding = 0) uniform PL_DYNAMIC_DATA
{
    plGpuDynFilterSpec tData;
} tDynamicData;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 3) in;

void
main()
{
    const float fXCoord = gl_WorkGroupID.x * 16 + gl_LocalInvocationID.x;
    const float fYCoord = gl_WorkGroupID.y * 16 + gl_LocalInvocationID.y;

    const int iFace = int(gl_WorkGroupID.z * 3 + gl_LocalInvocationID.z);
    const float fXinc = 1.0 / tDynamicData.tData.iResolution;
    const float fYinc = 1.0 / tDynamicData.tData.iResolution;
    const vec2 tInUV = vec2(fXCoord * fXinc, fYCoord * fYinc);
    const int iCurrentPixel = int(fXCoord + fYCoord * tDynamicData.tData.iWidth); 

    vec2 tNewUV = tInUV * (1 << tDynamicData.tData.iCurrentMipLevel);
    tNewUV = tNewUV * 2.0 - 1.0;

    const vec3 tScan = pl_uv_to_xyz(iFace, tNewUV);

    vec3 tN = normalize(tScan);

    vec3 tColor = vec3(0.0);
    for(int i = 0; i < tDynamicData.tData.iSampleCount; ++i)
    {

        vec2 tXi = pl_hammersley_2d(i, tDynamicData.tData.iSampleCount);
        vec3 tSampleDirection = pl_get_importance_sample_cosine(tXi, tN);

        float NoL = dot(tN, tSampleDirection);
        // float fPdf = NoL / PL_PI;
        float fPdf = NoL;

        // mipmap filtered samples (GPU Gems 3, 20.4)
        float fLod = 0.5 * log2( 6.0 * float(tDynamicData.tData.iWidth) * float(tDynamicData.tData.iWidth) / (float(tDynamicData.tData.iSampleCount) * fPdf));

        // apply the bias to the lod
        fLod += tDynamicData.tData.fLodBias;

        // sample lambertian at a lower giResolution to avoid fireflies
        const vec3 tSampleColor = textureLod(samplerCube(uCubeMap, tDefaultSampler), tSampleDirection, fLod).rgb;

        //// the below operations cancel each other out
        // lambertian *= NdotH; // lamberts law
        // lambertian /= pdf; // invert bias from importance sampling
        // lambertian /= PL_PI; // convert irradiance to radiance https://seblagarde.wordpress.com/2012/01/08/pi-or-not-to-pi-in-game-lighting-equation/

        tColor += tSampleColor;
    }

    tColor /= float(tDynamicData.tData.iSampleCount);
    tColor *= PL_PI;

    const vec4 tColorOut = vec4(tColor.rgb, 1.0);

    if (iFace == 0)
        tFaceOut0.atPixelData[iCurrentPixel] = tColorOut;
    else if (iFace == 1)
        tFaceOut1.atPixelData[iCurrentPixel] = tColorOut;
    else if (iFace == 2)
        tFaceOut2.atPixelData[iCurrentPixel] = tColorOut;
    else if (iFace == 3)
        tFaceOut3.atPixelData[iCurrentPixel] = tColorOut;
    else if (iFace == 4)
        tFaceOut4.atPixelData[iCurrentPixel] = tColorOut;
    else if(iFace == 5)
        tFaceOut5.atPixelData[iCurrentPixel] = tColorOut;
}