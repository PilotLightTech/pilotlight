#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(set = 0, binding = 0)  uniform sampler tSampler;
layout(set = 0, binding = 1)  uniform texture2D tTexture;
layout (set = 0, binding = 2, rgba32f) uniform writeonly image2D outputImage;

layout(set = 3, binding = 0) uniform PL_DYNAMIC_DATA
{
    int sourceLevel;
} tObjectInfo;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() 
{

    const int iXCoord = int(gl_GlobalInvocationID.x);
    const int iYCoord = int(gl_GlobalInvocationID.y);

    vec2 dstTextSize = textureSize(sampler2D(tTexture, tSampler), tObjectInfo.sourceLevel + 1);
    vec2 srcTextSize = textureSize(sampler2D(tTexture, tSampler), tObjectInfo.sourceLevel);

    vec2 tCenter = vec2((0.25 + float(iXCoord)) / dstTextSize.x, (0.25 + float(iYCoord)) / dstTextSize.y);

    vec4 result = vec4(0);

    const float weight[9] = {
        1.0 / 16.0,  1.0 / 8.0,  1.0 / 16.0, 
        1.0 /  8.0,  1.0 / 4.0,  1.0 /  8.0, 
        1.0 / 16.0,  1.0 / 8.0,  1.0 / 16.0
    };

    // Perform all arithmetic on float for performance until
    // we are forced to convert to an integer.
    int i = 0;
    for (vec2 offset = vec2(-1, -1); offset.y <= 1.0; ++offset.y)
    {
        for (offset.x = -1.0; offset.x <= 1.0; ++offset.x, ++i)
        {
            vec4 v = textureLod(sampler2D(tTexture, tSampler), vec2(clamp(tCenter + offset / srcTextSize, vec2(0), vec2(1.0))), tObjectInfo.sourceLevel);
            result += v * weight[i];
        }
    }

    imageStore(outputImage, ivec2(iXCoord, iYCoord), result);
}