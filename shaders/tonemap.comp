#version 450
#extension GL_ARB_separate_shader_objects : enable

#include "math.glsl"
#include "pl_shader_interop_renderer.h"

//simple fit from: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 ACESFilmApproximate(vec3 x)
{
    float a = 2.51;
    float b = 0.03;
    float c = 2.43;
    float d = 0.59;
    float e = 0.14;
    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0, 1);
}

//code from: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl
//licensed under MIT license
const mat3 ACESInputMat =
{
    {0.59719, 0.35458, 0.04823},
    {0.07600, 0.90834, 0.01566},
    {0.02840, 0.13383, 0.83777}
};

// ODT_SAT => XYZ => D60_2_D65 => sRGB
const mat3 ACESOutputMat =
{
    { 1.60475, -0.53108, -0.07367},
    {-0.10208,  1.10813, -0.00605},
    {-0.00327, -0.07276,  1.07602}
};

vec3 RRTAndODTFit(vec3 v)
{
    vec3 a = v * (v + 0.0245786f) - 0.000090537f;
    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
    return a / b;
}

// tone mapping
vec3 toneMapACES_Hill(vec3 color)
{
    color = transpose(ACESInputMat) * color;

    // Apply RRT and ODT
    color = RRTAndODTFit(color);

    color = transpose(ACESOutputMat) * color;

    // Clamp to [0, 1]
    color = clamp(color, 0.0, 1.0);

    return color;
}

mat3 saturationMatrix(float saturation)
{
	vec3 luminance = vec3(0.3086, 0.6094, 0.0820);
	float oneMinusSat = 1.0 - saturation;

	vec3 red = vec3(luminance * oneMinusSat);
	red += vec3(saturation, 0, 0);

	vec3 green = vec3(luminance * oneMinusSat);
	green += vec3(0, saturation, 0);

	vec3 blue = vec3(luminance * oneMinusSat);
	blue += vec3(0, 0, saturation);

	return mat3(red, green, blue);
}

vec3 toneMap_KhronosPbrNeutral( vec3 color )
{
    const float startCompression = 0.8 - 0.04;
    const float desaturation = 0.15;

    float x = min(color.r, min(color.g, color.b));
    float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
    color -= offset;

    float peak = max(color.r, max(color.g, color.b));
    if (peak < startCompression) return color;

    const float d = 1. - startCompression;
    float newPeak = 1. - d * d / (peak + d - startCompression);
    color *= newPeak / peak;

    float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
    return mix(color, newPeak * vec3(1, 1, 1), g);
}

layout (set = 0, binding = 0, rgba16f) uniform image2D inputImage;

//-----------------------------------------------------------------------------
// [SECTION] dynamic bind group
//-----------------------------------------------------------------------------

layout(set = 3, binding = 0) uniform PL_DYNAMIC_DATA
{
    plGpuDynTonemap tData;
} tDynamicData;


//-----------------------------------------------------------------------------
// [SECTION] entry
//-----------------------------------------------------------------------------

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

void
main() 
{

    const int iXCoord = int(gl_WorkGroupID.x * 32 + gl_LocalInvocationID.x);
    const int iYCoord = int(gl_WorkGroupID.y * 32 + gl_LocalInvocationID.y);

    const ivec2 tImageSize = imageSize(inputImage);
    
    if(iXCoord >= tImageSize.x || iYCoord >= tImageSize.y)
        return;

    const ivec2 tCenter = ivec2(iXCoord, iYCoord);

    vec4 tLinearColor = imageLoad(inputImage, tCenter);

    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_NONE)
    {
        imageStore(inputImage, tCenter, tLinearColor);
        return;
    }

    tLinearColor.rgb *= tDynamicData.tData.fExposure;

    vec3 tTonemappedColor;

    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_SIMPLE)
    {
        tTonemappedColor = tLinearColor.rgb;
    }
    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_KHRONOS_PBR_NEUTRAL)
    {
        tTonemappedColor = toneMap_KhronosPbrNeutral(tLinearColor.rgb);
    }
    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_ACES_NARKOWICZ)
    {
        tTonemappedColor = ACESFilmApproximate(tLinearColor.rgb);
    }
    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_ACES_HILL)
    {
        tTonemappedColor = toneMapACES_Hill(tLinearColor.rgb);
    }
    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_ACES_HILL_EXPOSURE_BOOST)
    {
        tLinearColor.rgb /= 0.6;
        tTonemappedColor = toneMapACES_Hill(tLinearColor.rgb);
    }
    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_REINHARD)
    {
        tTonemappedColor = tLinearColor.rgb / (tLinearColor.rgb + vec3(1));
    }
    vec3 sRGB = pl_linear_to_srgb(tTonemappedColor);

	sRGB.rgb = (sRGB.rgb - 0.5) * tDynamicData.tData.fContrast + 0.5 + tDynamicData.tData.fBrightness;
	sRGB.rgb = sRGB.rgb * saturationMatrix(tDynamicData.tData.fSaturation);

    sRGB.r = pl_saturate(sRGB.r);
    sRGB.g = pl_saturate(sRGB.g);
    sRGB.b = pl_saturate(sRGB.b);

    vec4 tFinalColor = vec4(sRGB, tLinearColor.a);
    imageStore(inputImage, tCenter, tFinalColor);
    
}