#version 450
#extension GL_ARB_separate_shader_objects : enable

#include "math.glsl"
#include "pl_shader_interop_renderer.h"

//simple fit from: https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/
vec3 ACESFilmApproximate(vec3 x)
{
    float a = 2.51f;
    float b = 0.03f;
    float c = 2.43f;
    float d = 0.59f;
    float e = 0.14f;
    return clamp((x*(a*x+b))/(x*(c*x+d)+e), 0, 1);
}

//code from: https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl
//licensed under MIT license
const mat3 ACESInputMat =
{
    {0.59719, 0.35458, 0.04823},
    {0.07600, 0.90834, 0.01566},
    {0.02840, 0.13383, 0.83777}
};

// ODT_SAT => XYZ => D60_2_D65 => sRGB
const mat3 ACESOutputMat =
{
    { 1.60475, -0.53108, -0.07367},
    {-0.10208,  1.10813, -0.00605},
    {-0.00327, -0.07276,  1.07602}
};

vec3 RRTAndODTFit(vec3 v)
{
    vec3 a = v * (v + 0.0245786f) - 0.000090537f;
    vec3 b = v * (0.983729f * v + 0.4329510f) + 0.238081f;
    return a / b;
}

//matrices are transposed because they are from HLSL code
vec3 ACESFitted(vec3 color)
{
    color = transpose(ACESInputMat) * color;

    // Apply RRT and ODT
    color = RRTAndODTFit(color);
    color = transpose(ACESOutputMat) * color;
    color = clamp(color, 0, 1);
    return color;
}

mat3 saturationMatrix(float saturation)
{
	vec3 luminance = vec3(0.3086, 0.6094, 0.0820);
	float oneMinusSat = 1.0 - saturation;

	vec3 red = vec3(luminance * oneMinusSat);
	red += vec3(saturation, 0, 0);

	vec3 green = vec3(luminance * oneMinusSat);
	green += vec3(0, saturation, 0);

	vec3 blue = vec3(luminance * oneMinusSat);
	blue += vec3(0, 0, saturation);

	return mat3(red, green, blue);
}

layout (set = 0, binding = 0, rgba16f) uniform image2D inputImage;

//-----------------------------------------------------------------------------
// [SECTION] dynamic bind group
//-----------------------------------------------------------------------------

layout(set = 3, binding = 0) uniform PL_DYNAMIC_DATA
{
    plGpuDynTonemap tData;
} tDynamicData;


//-----------------------------------------------------------------------------
// [SECTION] entry
//-----------------------------------------------------------------------------

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void
main() 
{

    const int iXCoord = int(gl_WorkGroupID.x * 8 + gl_LocalInvocationID.x);
    const int iYCoord = int(gl_WorkGroupID.y * 8 + gl_LocalInvocationID.y);

    const ivec2 tImageSize = imageSize(inputImage);
    
    if(iXCoord >= tImageSize.x || iYCoord >= tImageSize.y)
        return;

    const ivec2 tCenter = ivec2(iXCoord, iYCoord);

    vec4 tLinearColor = imageLoad(inputImage, tCenter);

    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_NONE)
    {
        imageStore(inputImage, tCenter, tLinearColor);
        return;
    }

    tLinearColor.rgb *= tDynamicData.tData.fExposure;

    vec3 tTonemappedColor;

    if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_SIMPLE)
    {
        tTonemappedColor = tLinearColor.rgb;
    }
    else if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_ACES)
    {
        tTonemappedColor = ACESFitted(tLinearColor.rgb);
    }
    else if(tDynamicData.tData.iMode == PL_TONEMAP_MODE_REINHARD)
    {
        tTonemappedColor = tLinearColor.rgb / (tLinearColor.rgb + vec3(1));
    }
    vec3 sRGB = pl_linear_to_srgb(tTonemappedColor);

	sRGB.rgb = (sRGB.rgb - 0.5) * tDynamicData.tData.fContrast + 0.5 + tDynamicData.tData.fBrightness;
	sRGB.rgb = sRGB.rgb * saturationMatrix(tDynamicData.tData.fSaturation);

    sRGB.r = pl_saturate(sRGB.r);
    sRGB.g = pl_saturate(sRGB.g);
    sRGB.b = pl_saturate(sRGB.b);

    vec4 tFinalColor = vec4(sRGB, tLinearColor.a);
    imageStore(inputImage, tCenter, tFinalColor);
    
}